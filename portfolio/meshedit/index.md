---
layout: single-page
---

<h1 style="text-align:center">CS 184: Computer Graphics and Imaging, Spring 2017</h1>
<h1 style="text-align:center">Project 2: Mesh Editor</h1>
<h1 style="text-align:center">Vivien Nguyen, cs184-acd</h1>
<hr>

<h2>Overview</h2>
<p>For this project, I've implemented various algorithms and subroutines to create and render meshes. I also wrote a few simple shaders using the Phong shading method. In more detail: I began with implementing Bezier curves with 1D de Casteljau subdivision, then extended it to surfaces. From there, I was able to render 3D meshes, as well as apply area-weighted surface normals to display surfaces more smoothly. After that, I explored the halfedge data structure/halfedge mesh and implemented some basic halfedge operations - flip and split. Then, using these basic operations, I was able to implement Loop subdivision to upsample my meshes. Finally, I worked on some shaders in GLSL to get specular shading (Phong shading) in various colors.</p>
<br>

<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

<p>de Casteljau's algorithm is a way of approximating a curve given a collection of control points. The algorithm specifies that for each edge between every pair of consecutive points, insert a new point at a linearly interpolated location on the edge (paramaterized by <em>t</em>). Then, draw an edge between every pair of consecutive points from the set of new points. When there's only one point left, that point lies exactly on the approximating curve at the interpolated location parameterized by t. Running this algorithm for every t (0, 1) will draw out the Bezier curve.</p>
<br>
<p>I personally found it most helpful to consider de Casteljau's algorithm as recursive corner cutting. For the actual code I wrote, I had a single "evaluateStep" function that calculated the next set of points given a specific t and a set of (arbitrary) points - whether they were the original control points or some set of points at some point in a run of de Casteljau's was essentially abstracted away, which makes sense given the recurisve nature of the algorithm.</p>
<br>
<p>Below are some screenshots of each step of de Casteljau's algorithm, as well as the final curve produced. Also shown is a curve generated by moving a few points around (from the same file as the original curve).</p>

<div class="row">
<div class="col">
<img src="images/bzc_1.png" class="img-fluid"/>
<figcaption align="middle">t = .5; Step 1</figcaption>
</div>
<div class="col">
<img src="images/bzc_2.png" class="img-fluid"/>
<figcaption align="middle">t = .5; Step 2</figcaption>
</div>
<div class="col">
<img src="images/bzc_3.png" class="img-fluid"/>
<figcaption align="middle">t = .5; Step 3</figcaption>
</div>
<div class="col">
<img src="images/bzc_4.png" class="img-fluid"/>
<figcaption align="middle">t = .5; Step 4</figcaption>
</div>
</div>
<div class="row">
<div class="col">
<img src="images/bzc_5.png" class="img-fluid"/>
<figcaption align="middle">t = .5; Step 5</figcaption>
</div>
<div class="col">
<img src="images/bzc_6.png" class="img-fluid"/>
<figcaption align="middle">t = .5; Step 5 - full curve</figcaption>
</div>
<div class="col">
<img src="images/bzc_7.png" class="img-fluid"/>
<figcaption align="middle">t = ~.75; Step 5 - full curve</figcaption>
</div>
</div>
<br>

<h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>
<div class="row">
<div class="col-md-8">
<p>There a number of ways to evaluate Bezier surfaces, including separable 1D subdivisions, bilinear 2D subdivisions, and algebraic evaluation (Bernstein polynomials). For this part, I took advantage of the suggested helper function to create Bezier surfaces via separable 1D subdivisions. Given a set of points that represented a patch, I applied de Casteljau's subdivision on each row of this patch (4 points in each row), then applied de Casteljau's to the four resulting points. This turns out to work functionally exactly the same way regular 1D de Casteljau subdivision works - just applied in both dimensions.</p>
</div>
<div class="col">
<img src="images/bez_1.png" class="img-fluid"/>
<figcaption align="middle">Hello, World!</figcaption>
</div>
</div>
<br>

<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 3: Average normals for half-edge meshes</h3>

<p>For this part, we want to implement area-weighted average normals to achieve a somewhat more realistic shading on our mesh. To do this, we can use the nature of the HalfedgeMesh to traverse around each face that shares the source vertex, and get that face's area-weighted average. I ran into some problems during this phase due to not reading the actual code for face()->normal, not realizing those vectors were already normalized! I wasn't sure how to proceed until I realized it was relatively trivial to just use the code existing in the face()->normal function and use that as a template to write my own helper function that returned an unnormalized normal vector. Then, we can just add all those vectors and normalize them.</p>
<br>

<div class="row">
<div class="col">
<img src="images/dae_1.png" class="img-fluid"/>
<figcaption align="middle">Flat shading</figcaption>
<img src="images/dae_2.png" class="img-fluid"/>
<figcaption align="middle">Area-averaged normals shading</figcaption>
</div>
<div class="col">
<img src="images/dae_4.png" class="img-fluid"/>
<figcaption align="middle">Flat shading, GLSL shader</figcaption>
<img src="images/dae_3.png" class="img-fluid"/>
<figcaption align="middle">Area-averaged normals shading, GLSL shader</figcaption>
</div></div>
<br>

<h3 align="middle">Part 4: Half-edge flip</h3>

<p>I began by drawing out the local HalfedgeMesh before and after the halfedge flip operation. I quite verbosely initialized pointers to every local element and set every halfedge's neighbors using the setNeighbors function. I also set all the vertices, faces, and edges halfedge references appropriately. I was not too concerned with redundancy in an effort to be as precise as possible. (Admittedly, I had originally been determined to only set pointers to what I thought was necessary, but quickly realized it was too much to keep track of).</p>
<br>

<p>In terms of debugging, it mostly involved checking for typos and performing edge flips on the mesh to take note of errors that occurred. For example, an initial bug made it seem like my faces were flipping inward or disappearing, so realized the bug likely had to do with setting pointers to faces.</p>
<br>
<div class="row">
<div class="col">
<img src="images/flip_1.png" class="img-fluid"/>
<figcaption align="middle">The cow mesh</figcaption>
<img src="images/flip_2.png" class="img-fluid"/>
<figcaption align="middle">The cow mesh after flipping some edges</figcaption>
</div>
<div class="col">
<img src="images/flip_3.png" class="img-fluid"/>
<figcaption align="middle">The quadball mesh</figcaption>
<img src="images/flip_4.png" class="img-fluid"/>
<figcaption align="middle">The quadball mesh after flipping some edges</figcaption>
</div>
</div>
<br>

<h3 align="middle">Part 5: Half-edge split</h3>

<p>My experience in the previous part helped tremendously here - I was much more cautious/precise with my pointers, which made the split operation work correctly on almost my first try (!!!) only barring some typos. </p>
<br>

<div class="row">
<div class="col">
<img src="images/split_1.png" class="img-fluid"/>
<figcaption align="middle">Cube mesh pre-edge operation</figcaption>
<img src="images/split_2.png" class="img-fluid"/>
<figcaption align="middle">Cube mesh after some edge splits (pretty cool spiral effect)</figcaption>
</div>
<div class="col">
<img src="images/split_3.png" class="img-fluid"/>
<figcaption align="middle">Teapot mesh after many arbitrary flips and splits</figcaption>
<img src="images/split_4.png" class="img-fluid"/>
<figcaption align="middle">Effects of flips and splits made clear with area-averaged shader</figcaption>
</div>
</div>
<br>

<div class="row">
<div class="col-md-6">
<h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>
<p>To correctly implement Loop subdivision, I tried to stick as closely as possible to the described algorithm. First, I went through every vertex in the mesh and calculated its new position based on a weighted average of its neighbors. Then, I went through every edge in the mesh and calculated the position of its split point, once again based on a weighted average of its neighbors. Next, I went through each edge again, this time actually performing the split operation and storing the previously calculated position into the split point's new position variable (the split point was initialized as the simple split point - the edge's midpoint). Now came what was personally the trickiest part for me (initially because I entirely forgot it was necessary) - flipping the appropriate edges. I had a lot of trouble wrapping my head around why and how to flip edges in this case.</p>
<br>
<p>Since I hadn't realized flipping edges was necessary, I actually implemented changing the vertex positions first, which was not too difficult - simply iterate through all the vertices that exist in the mesh now (remembering that we had created new ones previously), and updating their position to be their new position. When I realized that flipping some of the edges in the mesh was necessary, I realized it was pretty easy to just comment out this vertex movement to get a better idea of why my subdivision scheme wasn't working. It was pretty easy to see on the cube - the new edges created did not look anything like the even 1-to-4 triangle division shown in the specs. From there, I noticed the need to flip the new edges created if they were connecting an old and a new vertex (shout out to Piazza friends, as well). Then I could uncomment readjusting the vertex positions, and suddenly everything worked! I did a little dance around my apartment at 2 in the morning.</p>
<br>
<p>Loop subdivision seems to have a very dramatic effect on sharp corners and edges. That makes a lot of sense - since it essentially computes new vertex positions based on the average of its neighbors, and sharp corners and edges mean the surrounding vertices have very dramatic changes in position, these meshes will exhibit very dramatic results when upsampling (with diminishing drama on each upsample level). This is very easy to see if you compare the results of upsampling between the cube/torus/isocahedron and the teapot, which is already very smooth. The former shapes change into almost unrecognizable forms, while the teapot only results in smoothing around the joints.</p>
<br>
<p>Pre-splitting the edges gives some interesting effects - both alleviating the dramatic changes between none/a single level of Loop subdivision and also adding some changes to the geometry of the resulting mesh. Shown below are some increased symmetry in the cube mesh with pre-processing, and some increased wonkiness in the torus mesh with pre-processing. For the cube in particular, it's pretty convincing that since symmetry in the original cube mesh only exists from left to right across the diagonal, then upsampling will maintain this symmetry. Pre-processing to obtain an overall more symmetric mesh results in overall eventual symmetry in the limit surface.</p>

</div>
<div class="col">
<img src="images/loop_21.png" class="img-fluid"/>
<figcaption align="middle">Regular teapot mesh</figcaption>
<img src="images/loop_3.png" class="img-fluid"/>
<figcaption align="middle">Regular torus mesh</figcaption>
<img src="images/loop_6.png" class="img-fluid"/>
<figcaption align="middle">Pre-processed torus mesh</figcaption>
<img src="images/loop_16.png" class="img-fluid"/>
<figcaption align="middle">Regular cube</figcaption>
<img src="images/loop_18.png" class="img-fluid"/>
<figcaption align="middle">Two upsamples</figcaption>
<img src="images/loop_10.png" class="img-fluid"/>
<figcaption align="middle">Pre-processed cube mesh</figcaption>
<img src="images/loop_12.png" class="img-fluid"/>
<figcaption align="middle">Two upsamples</figcaption>
</div>
<div class="col">
<img src="images/loop_22.png" class="img-fluid"/>
<figcaption align="middle">Teapot mesh after one Loop subdivision - a little smoother, but not much difference.</figcaption>
<img src="images/loop_4.png" class="img-fluid"/>
<figcaption align="middle">Torus mesh upsampled once - very dramatic!</figcaption>
<img src="images/loop_7.png" class="img-fluid"/>
<figcaption align="middle">Upsampled - lumpy, but less dramatic "shrinkage" from a single call.</figcaption>
<img src="images/loop_17.png" class="img-fluid"/>
<figcaption align="middle">Regular cube - upsampled once. Where's the symmetry? :(</figcaption>
<img src="images/loop_20.png" class="img-fluid"/>
<figcaption align="middle">Four upsamples and from the front</figcaption>
<img src="images/loop_11.png" class="img-fluid"/>
<figcaption align="middle">Much more symmetric - one upsample</figcaption>
<img src="images/loop_15.png" class="img-fluid"/>
<figcaption align="middle">Four upsamples and from the front</figcaption>
</div>
</div>
<br>

<h2 align="middle">Section III: Shaders</h2>

<h3 align="middle">Part 7: Fun with shaders</h3>

<p>Basically implementing Phong shading using the slides, textbook, and GLSL tutorials as references. It was relatively simple once I figured out the quirks of GLSL as a language, as well as reinforced by understanding about the light/eye/normal vectors, etc. Modified the Phong shader function slightly to accept colors and lighting parameters as variables, so I could change and make new ones easily.</p>
<br>
<div class="row">
<div class="col">
<img src="images/phong_1.png" class="img-fluid"/>
<figcaption align="middle">Went for a sort of shiny ceramic look for my first phong shader. rgb = [179, 199, 209], ka = .8, kd = 5, ks = 6, p = 500</figcaption>
<img src="images/phong_2.png" class="img-fluid"/>
<figcaption align="middle">I love showing this off</figcaption>
</div>
<div class="col">
<img src="images/phong_3.png" class="img-fluid"/>
<figcaption align="middle">Went for a more matte shader for the second one. rgb = [124, 41, 41], ka = .5, kd = 2, ks = 8, p = 50</figcaption>
<img src="images/phong_4.png" class="img-fluid"/>
<figcaption align="middle"></figcaption>
</div>
</div>

<br>
<h2 align="middle">Section IV: Mesh Competition</h2>

<h3 align="middle">Part 8: Design your own mesh!</h3>
<p>I tried creating a "piggy-bank" type mesh, but it's more just a really pink, really shiny, pig-esque figure.</p>
<br>
<div class="row">
<div class="col">
<img src="images/pig_1.png" class="img-fluid"/>
<figcaption align="middle">Pig model created in Blender</figcaption>
<img src="images/pig_2.png" class="img-fluid"/>
<figcaption align="middle">As we can see, Loop subdivision doesn't work too well - probably too many skinny triangles on the cylinders/cones used</figcaption>
</div>
<div class="col">
<img src="images/pig_1.png" class="img-fluid"/>
<figcaption align="middle">Phong params: rgb = [255, 222, 216], ka = .8, kd = 3, ks = 9, p = 1000</figcaption>
<img src="images/pig_2.png" class="img-fluid"/>
<figcaption align="middle">Also moved the light to position (10, -10, 10) to make the snout more visible</figcaption>
</div>
</div>
<br>

<h2 align="middle">Section V: Bloopers</h2>
<p>Haha, oops.</p>
<br>
<div class="row">
<div class="col">
<img src="images/blooper_1.png" class="img-fluid"/>
<figcaption align="middle"></figcaption>
</div>
<div class="col">
<img src="images/blooper_2.png" class="img-fluid"/>
<figcaption align="middle"></figcaption>
</div>
<div class="col">
<img src="images/blooper_3.png" class="img-fluid"/>
<figcaption align="middle"></figcaption>
</div>
</div>
